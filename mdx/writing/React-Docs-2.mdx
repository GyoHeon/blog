---
title: React Docsë¥¼ ì½ì - 2
description: ìƒˆë¡œì›Œì§„ React Docsë¥¼ ì½ì–´ë³´ì.
date: 2023.08.17
tags: React, Front-end
image: https://react.dev/images/home/conf2019/cover.svg
slug: React-Docs-2
---

ìƒˆë¡œìš´ ë¦¬ì•¡íŠ¸ ê³µì‹ë¬¸ì„œê°€ ë§Œë“¤ì–´ì ¸ì„œ, ì•„ì˜ˆ ê³µì‹ë¬¸ì„œë¥¼ í†µìœ¼ë¡œ ê³µë¶€í•´ë³´ê¸°ë¡œ í•˜ì˜€ë‹¤.

ì§€ê¸ˆ ì ì€ ë‚´ìš©ë“¤ì€ ê³µì‹ ë¬¸ì„œë¥¼ ê·¸ëŒ€ë¡œ ì ì€ê²Œ ì•„ë‹ˆë¼ í•„ìê°€ ëª°ëê±°ë‚˜ ì¤‘ìš”í•˜ë‹¤ê³  ìƒê°ë˜ì–´ì§€ëŠ” ê²ƒë“¤ë§Œ ì ì€ ê²ƒì´ë‹¤.

## Adding Interactivity

# New React Docs: 2

date: April 21, 2023
slug: 21
status: Published
tags: FrontEnd, React
summary: New React Docs Study
type: Post

ë¦¬ì•¡íŠ¸ì˜ ìƒˆë¡œìš´ ê³µì‹ë¬¸ì„œ 2ì¥.

ëª¨ë“  ë‚´ìš©ì„ ì ì€ ê²ƒì´ ì•„ë‹ˆë¼ ëª°ëë˜ ë‚´ìš©ì´ë‚˜ ì¤‘ìš”í•˜ë‹¤ê³  ìƒê°ë˜ëŠ” ë‚´ìš©ì„ ì •ë¦¬í•œ ê²ƒì´ë‹¤.

# Adding Interactivity

## Responding to Events

1. ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì— í•¨ìˆ˜ë¥¼ ì „ë‹¬í•´ì•¼í•œë‹¤. í˜¸ì¶œí•˜ë©´ ì•ˆëœë‹¤.

   > Functions passed to event handlers must be passed, not called. For example:
   >
   > | passing a function (correct)   | calling a function (incorrect)   |
   > | ------------------------------ | -------------------------------- |
   > | <button onClick={handleClick}> | <button onClick={handleClick()}> |

2. onScrollì„ ì œì™¸í•œ ëª¨ë“  ì´ë²¤íŠ¸ëŠ” bubblingëœë‹¤.

   > All events propagate in React except `onScroll`, which only works on the JSX tag you attach it to.

3. Capture ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¡œ (ì‹¬ì§€ì–´ stopPropagationì„ ì‹¤í–‰í•´ë„) ì´ë²¤íŠ¸ ìº¡ì³ë§ì‹œì— ì´ë²¤íŠ¸ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.

   > In rare cases, you might need to catch all events on child elements, _even if they stopped propagation_. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by adding `Capture` at the end of the event name:

   ```jsx
   <div
     onClickCapture={() => {
       /* this runs first */
     }}
   >
     <button onClick={(e) => e.stopPropagation()} />
     <button onClick={(e) => e.stopPropagation()} />
   </div>
   ```

4. ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ëŠ” side effectsë¥¼ ìœ„í•œ ìµœì ì˜ ì¥ì†Œë‹¤.

   > Absolutely! Event handlers are the best place for side effects.
   >
   > Unlike rendering functions, event handlers donâ€™t need to be [pure](https://beta.reactjs.org/learn/keeping-components-pure), so itâ€™s a great place to _change_ something-

## State: A Componentâ€™s Memory

1. ì»´í¬ë„ŒíŠ¸ëŠ” ì—¬ëŸ¬ ì •ë³´ë“¤ì„ â€œê¸°ì–µâ€í•´ì•¼ í•˜ëŠ”ë°, ë¦¬ì•¡íŠ¸ì—ì„œ ì»´í¬ë„ŒíŠ¸ì— íŠ¹í™”ëœ ë©”ëª¨ë¦¬ë¥¼ stateë¼ ë¶€ë¥¸ë‹¤.

   > Components need to â€œrememberâ€ things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called _state_.

2. Hookì€ ë¦¬ì•¡íŠ¸ê°€ ë Œë”ë§ ë ë•Œë§Œ ì‚¬ìš©ê°€ëŠ¥í•œ íŠ¹ìˆ˜í•œ í•¨ìˆ˜ë‹¤.

   > _Hooks_ are special functions that are only available while React is [rendering](https://react.dev/learn/render-and-commit#step-1-trigger-a-render).

3. importë¬¸ê³¼ ë¹„ìŠ·í•˜ê²Œ Hookì€ ì»´í¬ë„ŒíŠ¸ë‚˜ ì»¤ìŠ¤í…€ í›…ì˜ ìµœìƒìœ„ì—ì„œ ì‚¬ìš©ë˜ì–´ì•¼í•œë‹¤.

   > You â€œuseâ€ React features at the top of your component similar to how you â€œimportâ€ modules at the top of your file.

4. ë¦¬ì•¡íŠ¸ì˜ stateëŠ” ì–´ë–»ê²Œ ìƒíƒœ(ë¬´ì—‡ì„ ë¦¬í„´í• ì§€)ë¥¼ ê¸°ì–µí•˜ëŠ”ê°€?
   1. ë¦¬ì•¡íŠ¸ Hookì€ ê°„ê²°í•œ êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•´ ë§¤ ë Œë”ë§ë§ˆë‹¤ ë™ì¼í•œ ì‹¤í–‰ ìˆœì„œì— ì˜ì¡´í•œë‹¤.

      > Instead, to enable their concise syntax, Hooks **rely on a stable call order on every render of the same component.**

   2. Hook ì„ í•­ìƒ ìµœìƒìœ„ì—ì„œ ì‹¤í–‰í•œë‹¤ëŠ” ê·œì¹™ì„ ì§€í‚¨ë‹¤ë©´, Hookì€ í•­ìƒ ê°™ì€ ìˆœì„œë¡œ ì‘ë™ë˜ê¸° ë•Œë¬¸ì— ì˜ ì‘ë™í• ìˆ˜ ìˆë‹¤.

      > This works well in practice because if you follow the rule above (â€œonly call Hooks at the top levelâ€), Hooks will always be called in the same order.

   3. ë‚´ë¶€ì ìœ¼ë¡œ ë¦¬ì•¡íŠ¸ì˜ ëª¨ë“  ì»´í¬ë„ŒíŠ¸ëŠ” state ìŒìœ¼ë¡œ ëœ í•˜ë‚˜ì˜ ë°°ì—´ì„ ê°€ì§€ê³  ìˆë‹¤.

      > Internally, React holds an array of state pairs for every component.

      <aside>
ğŸ’¡ ê°œì¸ì ì¸ ìƒê°ìœ¼ë¡œ, ë¦¬ì•¡íŠ¸ì˜ ì»´í¬ë„ŒíŠ¸ëŠ” stateë¥¼ í´ë¡œì € ë³€ìˆ˜ë¡œ ê°€ì§€ëŠ” ë‚´ë¶€ í•¨ìˆ˜ë¼ëŠ” ìƒê°ì´ ë“ ë‹¤.

      </aside>
5. Propsì™€ ë‹¬ë¦¬ stateëŠ” ì˜¤ì§ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸(stateë¥¼ ì„ ì–¸í•œ) ë‚´ë¶€ì—ì„œë§Œ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤.

   > Unlike props, **state is fully private to the component declaring it. The parent component canâ€™t change it.**

## Render and Commit

1. Trigger a render

   > There are two reasons for a component to render:
   >
   > 1. Itâ€™s the componentâ€™sÂ **initial render.**
   > 2. The componentâ€™s (or one of its ancestorsâ€™)Â **state has been updated.**

   1. ì²˜ìŒ ì•±ì´ ì‹œì‘ë  ë•ŒëŠ” createRootë¥¼ íƒ€ê²Ÿ DOM nodeì™€ ì‹¤í–‰í•œ ë’¤ render ë©”ì„œë“œë¥¼ ì‹¤í–‰í•œë‹¤.

      ```jsx
      import Image from "./Image.js";
      import { createRoot } from "react-dom/client";

      const root = createRoot(document.getElementById("root"));
      root.render(<Image />);
      ```

   2. stateê°€ ì—…ë°ì´íŠ¸ ë˜ë©´ ë¦¬ë Œë”ë§ì´ ì¼ì–´ë‚œë‹¤.(queueë¡œ)

      > Once the component has been initially rendered, you can trigger further renders by updating its state with the `[set` function.](https://react.dev/reference/react/useState#setstate) Updating your componentâ€™s state automatically queues a render.

2. React renders your components

   > After you trigger a render, React calls your components to figure out what to display on screen. **â€œRenderingâ€ is React calling your components.**
   >
   > - **On initial render,**Â React will call the root component.
   > - **For subsequent renders,**Â React will call the function component whose state update triggered the render.

   1. ë¦¬ì•¡íŠ¸ê°€ ë Œë”ë§ì„ ì¼ìœ¼í‚¤ëŠ” ë°©ì‹ì€ ì¬ê·€ì ì´ë‹¤.(ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ê°€ ë Œë”ë§ë˜ë©´ ìì‹ ì»´í¬ë„ŒíŠ¸ë„ ë Œë”ë§ ë˜ëŠ” ì´ìœ ì´ë‹¤.)

      > This process is recursive: if the updated component returns some other component, React will render _that_ component next, and if that component also returns something, it will render _that_ component next, and so on.

3. React commits changes to the DOM

   > After rendering (calling) your components, React will modify the DOM.
   >
   > - **For the initial render,**Â React will use theÂ `[appendChild()](https://developer.mozilla.org/docs/Web/API/Node/appendChild)`Â DOM API to put all the DOM nodes it has created on screen.
   > - **For re-renders,**Â React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.

   1. ë¦¬ì•¡íŠ¸ëŠ” ë Œë”ë§ê°„ ì°¨ì´ê°€ ìˆëŠ” DOMë§Œ ë³€í™”ì‹œí‚¨ë‹¤.

      > **React only changes the DOM nodes if thereâ€™s a difference between renders.**

## State as a Snapshot

1. ë¦¬ì•¡íŠ¸ëŠ” ì´ë²¤íŠ¸ì˜ ë³€í™”ë¥¼ stateì˜ ì—…ë°ì´íŠ¸ë¡œ í•´ì¤˜ì•¼í•œë‹¤.

   > This means that for an interface to react to the event, you need to _update the state_.

2. Renderingì€ ì–´ëŠ í•œ ìˆœê°„ì˜ í•¨ìˆ˜ ë¦¬í„´ì´ë‹¤.

   > The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated **using its state at the time of the render.**

3. ë¦¬ì•¡íŠ¸ê°€ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¦¬ë Œë”ë§í•˜ë©´ stateë¥¼ ì œì™¸í•˜ê³ ëŠ” ì „ë¶€ ìƒˆë¡œ ë§Œë“ ë‹¤. stateëŠ” ë¦¬ë Œë”ë§ ì‹œì—ë§Œ ê°’ì´ ë³€í•œë‹¤.

   > When React re-renders a component:
   >
   > 1. React calls your function again.
   > 2. Your function returns a new JSX snapshot.
   > 3. React then updates the screen to match the snapshot youâ€™ve returned.

4. state valueëŠ” ì˜¤ì§ ë‹¤ìŒ ë Œë”ë§ì‹œì—ë§Œ ë³€í™”ëœë‹¤.

   > **Setting state only changes it for the _next_ render.**

   1. ê·¸ë˜ì„œ ì•„ë˜ì™€ ê°™ì€ ë²„íŠ¼ì˜ ë™ì‘ì€ ì¼ë°˜ì ì¸ ìƒê°ê³¼ ë‹¤ë¥´ë‹¤. ì´ëŠ” â€˜ì´ë²ˆ ë Œë”ë§â€™ì—ì„œì˜ state(number)ê°€ ê³ ì •ë˜ì–´ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

      ```jsx
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
      ```

      > Here is what this buttonâ€™s click handler tells React to do:
      >
      > 1. `setNumber(number + 1)`:Â `number`Â isÂ `0`Â soÂ `setNumber(0 + 1)`.
      >    - React prepares to changeÂ `number`Â toÂ `1`Â on the next render.
      > 2. `setNumber(number + 1)`:Â `number`Â isÂ `0`Â soÂ `setNumber(0 + 1)`.
      >    - React prepares to changeÂ `number`Â toÂ `1`Â on the next render.
      > 3. `setNumber(number + 1)`:Â `number`Â isÂ `0`Â soÂ `setNumber(0 + 1)`.
      >    - React prepares to changeÂ `number`Â toÂ `1`Â on the next render.

   2. í•˜ë‚˜ì˜ rendering(snapshot)ì•ˆì—ì„œ stateì˜ ê°’ì€ ì ˆëŒ€ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤.

      > **A state variableâ€™s value never changes within a render,** even if its event handlerâ€™s code is asynchronous.

## Queueing a Series of State Updates

1. ë¦¬ì•¡íŠ¸ëŠ” stateë¥¼ ì—…ë°ì´íŠ¸ í•˜ê¸°ì „ì— ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì˜ ëª¨ë“  ì½”ë“œë¥¼ ìˆ˜í–‰í•œë‹¤.

   > **React waits until _all_ code in the event handlers has run before processing your state updates.**

   1. ê·¸ ë•ì— ë‹¤ì–‘í•œ state(ì‹¬ì§€ì–´ ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ì— ì¡´ì¬í•˜ëŠ”) updateë„ ë§ì€ ë¦¬ë Œë”ë§ì´ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤.

      > This lets you update multiple state variablesâ€”even from multiple componentsâ€”without triggering too many [re-renders.](https://react.dev/learn/render-and-commit#re-renders-when-state-updates)

   2. í•˜ì§€ë§Œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ê°€ ì™„ì „íˆ ëë‚˜ê¸° ì „ì—ëŠ” UIê°€ ì—…ë°ì´íŠ¸ ë˜ì§€ì•Šìœ¼ë©°, ì´ í–‰ë™ì„ `batching`ì´ë¼ í•œë‹¤.

      > But this also means that the UI wonâ€™t be updated until _after_ your event handler, and any code in it, completes. This behavior, also known as **batching,** makes your React app run much faster.

2. setStateì— ê°’ì´ ì•„ë‹Œ functionì„ ë„˜ê²¨ì£¼ëŠ” ê²ƒìœ¼ë¡œ queueì— ìˆëŠ” ì´ì „ stateê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

   > you can pass a _function_ that calculates the next state based on the previous one in the queue

## Updating Objects in State

1. objectì˜ contents ìì²´ë¥¼ ë°”ê¾¸ëŠ” ê²ƒì„ mutationì´ë¼ í•œë‹¤.(ê·¸ì™€ ë°˜ëŒ€ë¡œ primitive valueëŠ” ê°’ì„ ë°”ê¿€ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ replaceí•œë‹¤ í•¨)

   > Technically, it is possible to change the contents of _the object itself_. **This is called a mutation:**

2. ì•„ì§ stateê°€ ì•„ë‹Œ objectëŠ” mutationí•´ë„ ìƒê´€ì—†ë‹¤.(ì–´ë–¤ ì½”ë“œë„ í•´ë‹¹ objectë¥¼ referencesí•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—.)

   > Mutation is only a problem when you change _existing_ objects that are already in state. Mutating an object youâ€™ve just created is okay because _no other code references it yet._

3. objectsëŠ” ì‚¬ì‹¤ nesting ë˜ì–´ ìˆëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë‹¤ë¥¸ objectë¥¼ pointing í•˜ê³  ìˆëŠ” ê²ƒì´ë‹¤.

   > An object like this appears â€œnestedâ€ in code:

   ```jsx
   let obj = {
     name: "Niki de Saint Phalle",
     artwork: {
       title: "Blue Nana",
       city: "Hamburg",
       image: "https://i.imgur.com/Sd1AgUOm.jpg",
     },
   };
   ```

   > However, â€œnestingâ€ is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a â€œnestedâ€ object. You are really looking at two different objects:

   ```jsx
   let obj1 = {
     title: "Blue Nana",
     city: "Hamburg",
     image: "https://i.imgur.com/Sd1AgUOm.jpg",
   };

   let obj2 = {
     name: "Niki de Saint Phalle",
     artwork: obj1,
   };
   ```

## Updfating Arrays in State

1. javescriptì˜ arrayëŠ” íŠ¹ë³„í•œ ì¢…ë¥˜ì˜ objectì´ë¯€ë¡œ, objectì˜ ë‚´ìš©ê³¼ ë™ì¼í•˜ê²Œ mutateë¥¼ í•˜ì§€ ë§ê³  ë¶ˆë³€ì„±ì„ ì§€í‚¤ë©´ì„œ arrayë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

---
title: React Docs를 읽자 - 2
description: 새로워진 React Docs를 읽어보자.
date: 2023.08.21
tags: React, Front-end
image: https://react.dev/images/home/conf2019/cover.svg
slug: React-Docs-2
---

새로운 리액트 공식문서가 만들어져서, 아예 공식문서를 통으로 공부해보기로 하였다.

지금 적은 내용들은 공식 문서를 그대로 적은게 아니라 필자가 몰랐거나 중요하다고 생각되어지는 것들만 적은 것이다.

## Adding Interactivity

React에서 시간에 따라 변화하는 데이터를 state라 한다.
이번 챕터에선 state를 컴포넌트에 추가하고 업데이트 하는 것을 배운다.

### Responding to Events

jsx에 이벤트 핸들러를 추가하기 위해선 jsx의 prop으로 함수를 전달해야 한다.
이때 함수는 미리 정의하거나 인라인으로 prop안에서 정의할 수 있다.

###### _주의!_

> 이벤트 핸들러에는 함수를 호출하는 것이 아니라 전달해야한다.
> jsx의 `{}`안에 있는 코드는 즉시 실행되기 때문이다.
> 따라서 이벤트 핸들러에서 함수를 호출하면 매 렌더링시에 함수를 실행한다.
>
> ```jsx
> | passing a function (correct)    | calling a function (incorrect)    |
> | ------------------------------- | --------------------------------- |
> | <button onClick={handleClick}/> | <button onClick={handleClick()}/> |
> ```

###### _주의!_

> onScroll을 제외한 모든 이벤트는 bubbling된다.

###### Stopping Propagation

이벤트 핸들러는 오직 이벤트 객체 하나만 인자로 받는다.

###### 자세히 알아보기

Capture 이벤트 핸들러로 이벤트 캡쳐링시에 이벤트를 실행할 수 있다.
이벤트 캡쳐링은 실제 이벤트보다 먼저 일어나므로 자식 컴포넌트에서 stopPropagation을 해도 이벤트 캡쳐링은 실행된다.

```jsx
<div
  onClickCapture={() => {
    /* this runs first */
  }}
>
  <button onClick={(e) => e.stopPropagation()} />
  <button onClick={(e) => e.stopPropagation()} />
</div>
```

###### (1장에서의 설명처럼) 이벤트 핸들러는 side effects를 위한 최적의 장소다.

렌더링 함수와 달리 이벤트 핸들러는 `순수`하지 않아도 된다. 따라서 state 등을 변화시키기 좋다.

---

### State: A Component’s Memory

컴포넌트는 인터랙션의 결과로 변화해야 한다.
이때 컴포넌트가 인터랙션의 결과를 기억하는 메모리를 state라 한다.

###### 일반 변수(regular variable)로 충분하지 않을 때

버튼을 누르면 카운트가 증가하는 코드이다.

```jsx
export default function App() {
  let count = 0;

  function handleClick() {
    count = count + 1;
  }

  return (
    <>
      <button onClick={handleClick}>count is : {count}</button>
    </>
  );
}
```

(리액트가 아니라면) 평범한 코드이지만, 이 코드는 전혀 작동하지 않는다.
그 이유는 아래 두 가지이다.

1. 로컬 변수는 렌더링시마다 초기화된다.
   따라서 렌더링이 진행될 때마다 count는 0이 된다.
   즉, 로컬 변수의 변화가 유지 되지 못한다.
2. 리액트는 로컬 변수의 변화는 알아차리지 못한다.
   따라서 로컬 변수는 리액트의 렌더링을 트리거하지 못한다.

위 두 가지 문제를 해결하기 위해선 아래와 같은 해결책이 필요하다.

1. 렌더링시에도 데이터가 유지 되어야한다.
2. 리액트의 렌더링을 트리거해야 한다.(리렌더링 해야 한다.)

`useState` 훅이 위의 두 가지 역할을 한다.

1. state value를 제공한다.
   state value는 렌더링시에도 그 값이 유지된다.
2. state setter function을 제공한다.
   state setter function은 state value를 업데이트하고 리액트의 렌더링을 트리거한다.

###### 훅(Hook)과 친해지기

리액트에서 `use`로 시작하는 함수들을 훅이라 한다.
Hook은 [렌더링](https://react.dev/learn/render-and-commit#step-1-trigger-a-render)시에만 사용가능한 특수한 함수다.

###### _주의!_

> import문과 비슷하게 Hook은 컴포넌트나 커스텀 훅의 최상위에서 사용되어야한다.
> 훅을 컨디션, 루프, 중첩함수 등에서 사용하면 안된다.

###### State 해부

`useState`는 state value와 state setter function을 반환한다.

```jsx
const [count, setCount] = useState(0);
const handleClick = () => setCount(count + 1);
```

컴포넌트가 렌더링 될 때마다 useState는 두 가지 값을 리턴한다.

1. state value (count)
   유지 하고 싶은 데이터
2. state setter function (setCount)
   state value를 업데이트하고 리액트의 렌더링을 트리거하는 함수

실제 렌더링시에는 아래와 같이 동작한다.

1. 초기값을 0으로 설정했기 때문에 count는 0이 된다.
   `[0, setCount]`
2. 버튼을 클릭하면 setCount(count + 1)이 실행된다.
   count가 0 이었으므로 이는 setCount(1)과 같다.
   따라서 리액트는 count를 1로 기억하고 리렌더링을 한다.
   `[1, setCount]`
3. 리렌더링이 완료되면 초기값에 상관없이 count를 1이라고 기억한다.
   따라서 count는 1이 된다.

###### 리액트는 어떻게 state를 기억하는가?

useState는 초기값과 다른 값이 들어가도 특별한 액션 없이 그 상태를 계속 유지한다.
즉, 식별자 없이도 state를 기억한다는 것이다.
이것이 가능한 이유는 아래와 같다.

내부적으로 리액트의 모든 컴포넌트는 state 쌍으로 된 하나의 배열을 가지고 있다.
이 배열은 컴포넌트가 렌더링 될 때마다 변한 값을 유지한다.
따라서 다른 식별자가 없어도 state는 렌더링이 되어도 그 값을 유지할 수 있는 것이다.
이때 state는 간결한 구조를 유지하기 위해 매 렌더링마다 동일한 실행 순서에 의존한다.
식별자 대신 state의 순서를 이용하는 것이다.
Hook 을 항상 최상위에서 실행한다는 규칙을 지킨다면, Hook은 항상 같은 순서로 작동되기 때문에 문제없이 작동한다.

> 💡 개인적인 생각으로, 리액트의 컴포넌트는 state를 클로저 변수로 가지는 내부 함수라는 생각이 든다.

###### State는 독립적이고 프라이빗하다.

State는 컴포넌트에 대해 독립적이다.
즉, 똑같은 컴포넌트를 두개 만들어도 컴포넌트가 가지는 state는 완전히 개별 state이다.

Props와 달리 state는 오직 state를 선언한 컴포넌트 내부에서만 관리할 수 있다.

---여기까지 함

---

### Render and Commit

###### Trigger a render

> There are two reasons for a component to render:
>
> 1.  It’s the component’s **initial render.**
> 2.  The component’s (or one of its ancestors’) **state has been updated.**

1.  처음 앱이 시작될 때는 createRoot를 타겟 DOM node와 실행한 뒤 render 메서드를 실행한다.

    ```jsx
    import Image from "./Image.js";
    import { createRoot } from "react-dom/client";

    const root = createRoot(document.getElementById("root"));
    root.render(<Image />);
    ```

2.  state가 업데이트 되면 리렌더링이 일어난다.(queue로)

    > Once the component has been initially rendered, you can trigger further renders by updating its state with the `[set` function.](https://react.dev/reference/react/useState#setstate) Updating your component’s state automatically queues a render.

###### React renders your components

> After you trigger a render, React calls your components to figure out what to display on screen. **“Rendering” is React calling your components.**
>
> - **On initial render,** React will call the root component.
> - **For subsequent renders,** React will call the function component whose state update triggered the render.

1.  리액트가 렌더링을 일으키는 방식은 재귀적이다.(부모 컴포넌트가 렌더링되면 자식 컴포넌트도 렌더링 되는 이유이다.)

    > This process is recursive: if the updated component returns some other component, React will render _that_ component next, and if that component also returns something, it will render _that_ component next, and so on.

###### React commits changes to the DOM

> After rendering (calling) your components, React will modify the DOM.
>
> - **For the initial render,** React will use the `[appendChild()](https://developer.mozilla.org/docs/Web/API/Node/appendChild)` DOM API to put all the DOM nodes it has created on screen.
> - **For re-renders,** React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.

1.  리액트는 렌더링간 차이가 있는 DOM만 변화시킨다.

    > **React only changes the DOM nodes if there’s a difference between renders.**

---

### State as a Snapshot

###### 리액트는 이벤트의 변화를 state의 업데이트로 해줘야한다.

> This means that for an interface to react to the event, you need to _update the state_.

###### Rendering은 어느 한 순간의 함수 리턴이다.

> The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated **using its state at the time of the render.**

###### 리액트가 컴포넌트를 리렌더링하면 state를 제외하고는 전부 새로 만든다. state는 리렌더링 시에만 값이 변한다.

> When React re-renders a component:
>
> 1.  React calls your function again.
> 2.  Your function returns a new JSX snapshot.
> 3.  React then updates the screen to match the snapshot you’ve returned.

###### state value는 오직 다음 렌더링시에만 변화된다.

> **Setting state only changes it for the _next_ render.**

1.  그래서 아래와 같은 버튼의 동작은 일반적인 생각과 다르다. 이는 ‘이번 렌더링’에서의 state(number)가 고정되어 있기 때문이다.

    ```jsx
    <button
      onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}
    >
      +3
    </button>
    ```

    > Here is what this button’s click handler tells React to do:
    >
    > 1. `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)`.
    >    - React prepares to change `number` to `1` on the next render.
    > 2. `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)`.
    >    - React prepares to change `number` to `1` on the next render.
    > 3. `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)`.
    >    - React prepares to change `number` to `1` on the next render.

2.  하나의 rendering(snapshot)안에서 state의 값은 절대 변하지 않는다.

    > **A state variable’s value never changes within a render,** even if its event handler’s code is asynchronous.

---

### Queueing a Series of State Updates

###### 리액트는 state를 업데이트 하기전에 이벤트 핸들러의 모든 코드를 수행한다.

> **React waits until _all_ code in the event handlers has run before processing your state updates.**

1.  그 덕에 다양한 state(심지어 다른 컴포넌트에 존재하는) update도 많은 리렌더링이 일어나지 않는다.

    > This lets you update multiple state variables—even from multiple components—without triggering too many [re-renders.](https://react.dev/learn/render-and-commit#re-renders-when-state-updates)

2.  하지만 이벤트 핸들러가 완전히 끝나기 전에는 UI가 업데이트 되지않으며, 이 행동을 `batching`이라 한다.

    > But this also means that the UI won’t be updated until _after_ your event handler, and any code in it, completes. This behavior, also known as **batching,** makes your React app run much faster.

###### setState에 값이 아닌 function을 넘겨주는 것으로 queue에 있는 이전 state값을 사용할 수 있다.

> you can pass a _function_ that calculates the next state based on the previous one in the queue

### Updating Objects in State

###### object의 contents 자체를 바꾸는 것을 mutation이라 한다.(그와 반대로 primitive value는 값을 바꿀 수 없으므로 replace한다 함)

> Technically, it is possible to change the contents of _the object itself_. **This is called a mutation:**

###### 아직 state가 아닌 object는 mutation해도 상관없다.(어떤 코드도 해당 object를 references하지 않기 때문에.)

> Mutation is only a problem when you change _existing_ objects that are already in state. Mutating an object you’ve just created is okay because _no other code references it yet._

###### objects는 사실 nesting 되어 있는 것이 아니라 다른 object를 pointing 하고 있는 것이다.

> An object like this appears “nested” in code:

```jsx
let obj = {
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
};
```

> However, “nesting” is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a “nested” object. You are really looking at two different objects:

```jsx
let obj1 = {
  title: "Blue Nana",
  city: "Hamburg",
  image: "https://i.imgur.com/Sd1AgUOm.jpg",
};

let obj2 = {
  name: "Niki de Saint Phalle",
  artwork: obj1,
};
```

---

### Updfating Arrays in State

###### javescript의 array는 특별한 종류의 object이므로, object의 내용과 동일하게 mutate를 하지 말고 불변성을 지키면서 array를 사용해야 한다.
